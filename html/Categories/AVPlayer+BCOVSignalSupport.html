<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>AVPlayer(BCOVSignalSupport) Category Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.2 (build 963)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">BCOVPlayerSDK </a></h1>
				<a id="developerHome" href="../index.html">Brightcove</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">AVPlayer(BCOVSignalSupport) Category Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/bcov_periodicTimeObserverSignalForInterval:">&nbsp;&nbsp;&nbsp;&nbsp;- bcov_periodicTimeObserverSignalForInterval:</option>
	
	<option value="//api/name/bcov_periodicTimeObserverSignalForInterval:queue:">&nbsp;&nbsp;&nbsp;&nbsp;- bcov_periodicTimeObserverSignalForInterval:queue:</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>









<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bcov_periodicTimeObserverSignalForInterval:">bcov_periodicTimeObserverSignalForInterval:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bcov_periodicTimeObserverSignalForInterval:queue:">bcov_periodicTimeObserverSignalForInterval:queue:</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="AVPlayer(BCOVSignalSupport) Category Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">AVPlayer(BCOVSignalSupport) Category Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">AVPlayer+BCOVSignalSupport.h</td>
</tr>
						</tbody></table></div>
					
                    
                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>Adds RACSignal support to AVPlayer methods.</p>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/bcov_periodicTimeObserverSignalForInterval:">&ndash;&nbsp;bcov_periodicTimeObserverSignalForInterval:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bcov_periodicTimeObserverSignalForInterval:queue:">&ndash;&nbsp;bcov_periodicTimeObserverSignalForInterval:queue:</a></code>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/bcov_periodicTimeObserverSignalForInterval:" title="bcov_periodicTimeObserverSignalForInterval:"></a>
	<h3 class="subsubtitle method-title">bcov_periodicTimeObserverSignalForInterval:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns a signal which sends a CMTime wrapped in an NSValue at the interval
specified. Values are also sent whenever time jumps and whenever playback
starts or stops, just like -addPeriodicTimeObserverForInterval:queue:usingBlock:.
That method&rsquo;s caveats regarding scheduling very short intervals apply to
this as well. The returned signal never completes; you must explicitly
dispose of the subscription to allow this AVPlayer to become released.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (RACSignal *)bcov_periodicTimeObserverSignalForInterval:(CMTime)<em>interval</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>interval</em></dt>
			<dd><p>The interval at which events should be sent to subscribers
during normal playback.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>A signal which sends values according to the specified interval.
The value sent is the current time of the player as a CMTime wrapped in an
NSValue.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns a signal which sends a CMTime wrapped in an NSValue at the interval
specified. Values are also sent whenever time jumps and whenever playback
starts or stops, just like -addPeriodicTimeObserverForInterval:queue:usingBlock:.
That method&rsquo;s caveats regarding scheduling very short intervals apply to
this as well. The returned signal never completes; you must explicitly
dispose of the subscription to allow this AVPlayer to become released.</p>

<p>The returned signal does not guarantee which thread its events will be
delivered on, so it is important to use [RACSignal deliverOn:RACScheduler.mainThreadScheduler]
to force events to be sent on the main thread if main thread execution is
required by subscribers. (A private serial queue is created for the periodic
observer.)</p>

<p>Note: the periodic time observer will be added (and removed) on the main
thread, regardless of which thread this method is called from, as is required
by AVFoundation.</p>

<p>Note: Adding the periodic observer while content is playing appears to cause
nondeterministic crashes due to a bug in AVFoundation.</p>

<p>Note: The -addPeriodicTimeObserverForInterval:queue:usingBlock: method will
create a strong reference to this AVPlayer instance, preventing it from being
released. To allow this AVPlayer to become released, you must explicitly
dispose of the returned signal.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AVPlayer+BCOVSignalSupport.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bcov_periodicTimeObserverSignalForInterval:queue:" title="bcov_periodicTimeObserverSignalForInterval:queue:"></a>
	<h3 class="subsubtitle method-title">bcov_periodicTimeObserverSignalForInterval:queue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns a signal which sends a CMTime wrapped in an NSValue at the interval
specified. Values are also sent whenever time jumps and whenever playback
starts or stops, just like -addPeriodicTimeObserverForInterval:queue:usingBlock:.
That method&rsquo;s caveats regarding scheduling very short intervals apply to
this as well. The returned signal never completes; you must explicitly
dispose of the subscription to allow this AVPlayer to become released.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (RACSignal *)bcov_periodicTimeObserverSignalForInterval:(CMTime)<em>interval</em> queue:(dispatch_queue_t)<em>serialQueue</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>interval</em></dt>
			<dd><p>The interval at which events should be sent to subscribers
during normal playback.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>serialQueue</em></dt>
			<dd><p>A serial dispatch queue on which the periodic time
observer should send events to the returned signal. Specifying NULL will
have the same effect as passing the main thread dispatch queue. Specifying a
concurrent dispatch queue will result in undefined behavior.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>A signal which sends values according to the specified interval.
The value sent is the current time of the player as a CMTime wrapped in an
NSValue.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns a signal which sends a CMTime wrapped in an NSValue at the interval
specified. Values are also sent whenever time jumps and whenever playback
starts or stops, just like -addPeriodicTimeObserverForInterval:queue:usingBlock:.
That method&rsquo;s caveats regarding scheduling very short intervals apply to
this as well. The returned signal never completes; you must explicitly
dispose of the subscription to allow this AVPlayer to become released.</p>

<p>The events sent to the returned signal will be queued on the specified
queue. Specifying NULL will have the same effect as specifying the main
thread&rsquo;s dispatch queue. However, it may be preferable to use
[RACSignal deliverOn:RACScheduler.mainThreadScheduler] to deliver the
events on the main thread after any further operations have been performed
on the events. Specifying a concurrent dispatch queue will result in
undefined behavior.</p>

<p>Note: the periodic time observer will be added (and removed) on the main
thread, regardless of which thread this method is called from, as is required
by AVFoundation.</p>

<p>Note: Adding the periodic observer while content is playing appears to cause
nondeterministic crashes due to a bug in AVFoundation.</p>

<p>Note: The -addPeriodicTimeObserverForInterval:queue:usingBlock: method will
create a strong reference to this AVPlayer instance, preventing it from being
released. To allow this AVPlayer to become released, you must explicitly
dispose of the returned signal.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AVPlayer+BCOVSignalSupport.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
                    
                    
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2014 Brightcove. All rights reserved. (Last updated: 2014-05-16)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2 (build 963)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>